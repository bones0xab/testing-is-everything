name: Microservice Spring Boot - Intégration Continue (CI)

# 1. Déclencheurs (Triggers)
# Le CI se lance à chaque push et sur chaque Pull Request vers la branche 'main'.
on:
  push:
    branches: [ "main", "develop", "feature/**" ] # Exécuter sur les branches principales et de feature
  pull_request:
    branches: [ "main", "develop" ] # Exécuter sur les PR vers les branches stables

# 2. Définition des Tâches (Jobs)
jobs:
  build_and_test:
    name: Build, Test et Qualité du Code
    runs-on: ubuntu-latest # Utilise la dernière version d'Ubuntu pour l'exécution

    steps:
      # --- Étape 1 : Préparation de l'Environnement ---
      - name: 1. Checkout du Code
        uses: actions/checkout@v4

      - name: 2. Configuration du JDK 17 (Nécessaire pour Spring Boot)
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven' # Mise en cache des dépendances Maven pour accélérer la CI

      # --- Étape 2 : Le Cœur de la CI (Build et Tests) ---
      # Cette commande exécute la compilation et lance tous les tests (unitaires & intégration).
      # L'option -DskipTests=false garantit que les tests s'exécutent.
      - name: 3. Exécution du Build et des Tests
        run: mvn clean install -DskipTests=false

      # --- Étape 3 : Gestion de l'Artefact (Prêt pour le CD) ---
      # Télécharge l'artefact (le fichier JAR) pour le rendre disponible aux étapes futures du CD.
      - name: 4. Téléversement de l'Artefact (.JAR)
        uses: actions/upload-artifact@v4
        with:
          name: spring-boot-microservice-jar
          path: target/*.jar # Répertoire de sortie typique de Maven
          retention-days: 1 # Garder l'artefact pendant un jour (pour les tests rapides)

      # --- Étape 4 (BONUS) : Contrôle de Qualité ---
      # Si vous utilisiez un outil comme SonarQube, ce serait l'étape ici.
      - name: 5. Affichage du Résultat du Build
        if: always()
        run: |
          echo "Le pipeline CI est terminé. Statut du build : ${{ job.status }}"
  # --- JOB 2: CONSTRUCTION ET PUSH DE L'IMAGE DOCKER (CD) ---
  build_and_push_docker:
    name: 2. Construction et Push de l'Image Docker
    runs-on: ubuntu-latest
    needs: build_and_test # Dépendance : Doit attendre le succès du job précédent

    steps:
      - name: 1. Checkout du Code
        uses: actions/checkout@v4

      - name: 2. Connexion à Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: 3. Définition des Variables de Tag
        id: vars
        run: |
          # 1. Récupère le nom du dépôt GitHub (ex: bones0xab/testing-is-everything)
          REPO_SLUG=$(echo ${{ github.repository }} | tr '[:upper:]' '[:lower:]')
          
          # 2. Extrait seulement le nom du projet (ex: testing-is-everything)
          # Utilisation de awk pour garantir que le nom est propre
          SIMPLE_REPO_NAME=$(echo $REPO_SLUG | awk -F/ '{print $2}')
          
          # 3. CONSTRUIT LE TAG CORRECT : DOCKER_USERNAME / SIMPLE_REPO_NAME
          # C'est la ligne qui résout l'erreur 'denied' : on utilise le DOCKER_USERNAME (0xbones1)
          IMAGE_NAME=${{ secrets.DOCKER_USERNAME }}/${SIMPLE_REPO_NAME}
          TAG_SHA=sha-${{ github.sha }}
          
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "TAG_SHA=$TAG_SHA" >> $GITHUB_OUTPUT

      - name: 4. Construction et Push de l'Image
        uses: docker/build-push-action@v5
        with:
          context: . # Utiliser le répertoire courant pour la construction
          file: ./Dockerfile # Utiliser le Dockerfile que vous avez créé à la racine
          push: true
          tags: |
            ${{ steps.vars.outputs.IMAGE_NAME }}:latest
            ${{ steps.vars.outputs.IMAGE_NAME }}:${{ steps.vars.outputs.TAG_SHA }}

      - name: 5. Affichage du Statut du Push
        if: success()
        run: echo "Image Docker poussée avec succès sur Docker Hub."